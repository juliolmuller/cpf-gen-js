{"version":3,"sources":["../node_modules/@lacussoft/num-only/src/index.js","../node_modules/@lacussoft/cpf-fmt/src/index.js","core/index.js","dist.js"],"names":["numOnly","require","cpfFmt","DEFAULT_OPTIONS","format","mergeOptions","options","Object","assign","numGen","length","string","String","parseInt","Math","random","cpfGen","arguments","undefined","Error","cpf","nextNumIndex","sum","factor","n","rem","module","exports","window"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxQA,IAAMA,OAAO,GAAGC,OAAO,CAAC,qBAAD,CAAvB;;AACA,IAAMC,MAAM,GAAGD,OAAO,CAAC,oBAAD,CAAtB;AAEA;;;;;;;AAKA,IAAME,eAAe,GAAG;AACtBC,EAAAA,MAAM,EAAE;AADc,CAAxB;;AAIA,IAAMC,YAAY,GAAG,SAAfA,YAAe,CAACC,OAAD,EAAa;AAChC,SAAOC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBL,eAAlB,EAAmCG,OAAnC,CAAP;AACD,CAFD;AAIA;;;;;;;;AAMA,IAAMG,MAAM,GAAG,SAATA,MAAS,CAACC,MAAD,EAAY;AACzB,MAAIC,MAAM,GAAG,EAAb;;AACA,SAAOA,MAAM,CAACD,MAAP,GAAgBA,MAAvB,EAA+B;AAC7BC,IAAAA,MAAM,IAAIC,MAAM,CAACC,QAAQ,CAACC,IAAI,CAACC,MAAL,KAAgB,EAAjB,CAAT,CAAhB;AACD;;AACD,SAAOJ,MAAP;AACD,CAND;AAQA;;;;;;;;AAMA,IAAMK,MAAM,GAAG,SAATA,MAAS,CAASV,OAAT,EAAkB;AAE/B,MAAIW,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAjB,IAA8B,OAAOD,SAAS,CAAC,CAAD,CAAhB,KAAyB,QAAvD,IAAmEjB,OAAO,CAACiB,SAAS,CAAC,CAAD,CAAV,CAAP,CAAsBP,MAAtB,KAAiC,CAAxG,EAA2G;AACzG,UAAM,IAAIS,KAAJ,YAAcF,SAAS,CAAC,CAAD,CAAvB,8CAAN;AACD;;AAED,MAAIG,GAAG,GAAGH,SAAS,CAAC,CAAD,CAAT,IAAgBR,MAAM,CAAC,CAAD,CAAhC;AACAH,EAAAA,OAAO,GAAGD,YAAY,CAACC,OAAD,CAAtB;;AAEA,0BAA2B,CAAC,CAAD,EAAI,EAAJ,CAA3B,0BAAoC;AAA/B,QAAMe,YAAY,WAAlB;AACH,QAAIC,GAAG,GAAG,CAAV;AACA,QAAIC,MAAM,GAAGF,YAAY,GAAG,CAA5B;;AACA,SAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,YAApB,EAAkCG,CAAC,IAAID,MAAM,EAA7C,EAAiD;AAC/CD,MAAAA,GAAG,IAAIF,GAAG,CAACI,CAAD,CAAH,GAASD,MAAhB;AACD;;AACD,QAAME,GAAG,GAAG,KAAMH,GAAG,GAAG,EAAxB;AACAF,IAAAA,GAAG,IAAIK,GAAG,GAAG,CAAN,GAAU,CAAV,GAAcA,GAArB;AACD;;AAED,MAAInB,OAAO,CAACF,MAAZ,EAAoB;AAClB,WAAOF,MAAM,CAACkB,GAAD,CAAb;AACD;;AAED,SAAOA,GAAP;AACD,CAxBD;;AA0BAM,MAAM,CAACC,OAAP,GAAiBX,MAAjB;;AC9DAY,MAAM,CAACZ,MAAP,GAAgBf,OAAO,CAAC,QAAD,CAAvB","file":"cpf-gen.js","sourceRoot":"..\\src","sourcesContent":["/**\r\n * Removes any non-numeric character from a string chaing\r\n *\r\n * @param {string} target\r\n * @returns {string} - Target string you want to clear from NaN characters\r\n */\r\nmodule.exports = function(target) {\r\n\r\n  return String(target).replace(/\\D/g, '')\r\n}\r\n","// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\nparcelRequire = (function (modules, cache, entry, globalName) {\n  // Save the require from previous bundle to this closure if any\n  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;\n  var nodeRequire = typeof require === 'function' && require;\n\n  function newRequire(name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        // if we cannot find the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;\n        if (!jumped && currentRequire) {\n          return currentRequire(name, true);\n        }\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) {\n          return previousRequire(name, true);\n        }\n\n        // Try the node require function if it exists.\n        if (nodeRequire && typeof name === 'string') {\n          return nodeRequire(name);\n        }\n\n        var err = new Error('Cannot find module \\'' + name + '\\'');\n        err.code = 'MODULE_NOT_FOUND';\n        throw err;\n      }\n\n      localRequire.resolve = resolve;\n      localRequire.cache = {};\n\n      var module = cache[name] = new newRequire.Module(name);\n\n      modules[name][0].call(module.exports, localRequire, module, module.exports, this);\n    }\n\n    return cache[name].exports;\n\n    function localRequire(x){\n      return newRequire(localRequire.resolve(x));\n    }\n\n    function resolve(x){\n      return modules[name][1][x] || x;\n    }\n  }\n\n  function Module(moduleName) {\n    this.id = moduleName;\n    this.bundle = newRequire;\n    this.exports = {};\n  }\n\n  newRequire.isParcelRequire = true;\n  newRequire.Module = Module;\n  newRequire.modules = modules;\n  newRequire.cache = cache;\n  newRequire.parent = previousRequire;\n  newRequire.register = function (id, exports) {\n    modules[id] = [function (require, module) {\n      module.exports = exports;\n    }, {}];\n  };\n\n  var error;\n  for (var i = 0; i < entry.length; i++) {\n    try {\n      newRequire(entry[i]);\n    } catch (e) {\n      // Save first error but execute all entries\n      if (!error) {\n        error = e;\n      }\n    }\n  }\n\n  if (entry.length) {\n    // Expose entry point to Node, AMD or browser globals\n    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js\n    var mainExports = newRequire(entry[entry.length - 1]);\n\n    // CommonJS\n    if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n      module.exports = mainExports;\n\n    // RequireJS\n    } else if (typeof define === \"function\" && define.amd) {\n     define(function () {\n       return mainExports;\n     });\n\n    // <script>\n    } else if (globalName) {\n      this[globalName] = mainExports;\n    }\n  }\n\n  // Override the current require with this new one\n  parcelRequire = newRequire;\n\n  if (error) {\n    // throw error from earlier, _after updating parcelRequire_\n    throw error;\n  }\n\n  return newRequire;\n})({\"wp2b\":[function(require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\r\n * Merge custom options to default ones\r\n *\r\n * @param {CpfFormatingOptions} options\r\n * @return {CpfFormatingOptions}\r\n */\n\nfunction mergeOptions(options) {\n  var _a = options.delimiters,\n      _b = _a === void 0 ? {} : _a,\n      _c = _b.dot,\n      dot = _c === void 0 ? '.' : _c,\n      _d = _b.dash,\n      dash = _d === void 0 ? '-' : _d,\n      _e = options.hiddenRange,\n      _f = _e === void 0 ? {} : _e,\n      _g = _f.start,\n      start = _g === void 0 ? 3 : _g,\n      _h = _f.end,\n      end = _h === void 0 ? 10 : _h,\n      _j = options.hiddenKey,\n      hiddenKey = _j === void 0 ? '*' : _j,\n      _k = options.hidden,\n      hidden = _k === void 0 ? false : _k,\n      _l = options.escape,\n      escape = _l === void 0 ? false : _l,\n      _m = options.onFail,\n      onFail = _m === void 0 ? function (value) {\n    throw new EvalError(\"'\" + value + \"' cannot be resolved to a CPF numeric sequence (11 digits)\");\n  } : _m;\n\n  if (hidden) {\n    if (Number(start) === NaN || start < 0 || start > 10) {\n      throw new TypeError('Option \\'hiddenRange.start\\' must be a callbacknumber between 0 and 10.');\n    }\n\n    if (Number(end) === NaN || end < 0 || end > 10) {\n      throw new TypeError('Option \\'hiddenRange.end\\' must be a callbacknumber between 0 and 10.');\n    }\n\n    if (start > end) {\n      start = start ^ end;\n      end = start ^ end;\n      start = start ^ end;\n    }\n  }\n\n  if (typeof onFail !== 'function') {\n    throw new TypeError('The option \\'onFail\\' must be a callback function.');\n  }\n\n  return {\n    delimiters: {\n      dot: dot,\n      dash: dash\n    },\n    hiddenRange: {\n      start: start,\n      end: end\n    },\n    hiddenKey: hiddenKey,\n    hidden: hidden,\n    escape: escape,\n    onFail: onFail\n  };\n}\n\nexports.default = mergeOptions;\n},{}],\"VRRp\":[function(require,module,exports) {\n\"use strict\";\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar html_escaper_1 = __importDefault(require(\"html-escaper\"));\n\nvar mergeOptions_1 = __importDefault(require(\"./mergeOptions\"));\n\nvar num_only_1 = __importDefault(require(\"@lacussoft/num-only\"));\n/**\r\n * Validate a given CPF (Brazilian ID document) char sequence\r\n *\r\n * @param {string} cpfString\r\n * @param {object} options\r\n * @return {string}\r\n */\n\n\nfunction default_1(cpfString, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var cpfNumbers = num_only_1.default(cpfString);\n  var finalOptions = mergeOptions_1.default(options);\n\n  if (cpfNumbers.length !== 11) {\n    return finalOptions.onFail(cpfString);\n  }\n\n  var cpfArray = __spreadArrays(cpfNumbers);\n\n  if (finalOptions.hidden) {\n    // eslint-disable-next-line max-len\n    for (var i = finalOptions.hiddenRange.start; i <= finalOptions.hiddenRange.end; i++) {\n      cpfArray[i] = finalOptions.hiddenKey;\n    }\n  }\n\n  cpfArray.splice(9, 0, finalOptions.delimiters.dash);\n  cpfArray.splice(6, 0, finalOptions.delimiters.dot);\n  cpfArray.splice(3, 0, finalOptions.delimiters.dot);\n  var cpfFormat = cpfArray.join('');\n\n  if (finalOptions.escape) {\n    return html_escaper_1.default.escape(cpfFormat);\n  }\n\n  return cpfFormat;\n}\n\nexports.default = default_1;\n},{\"./mergeOptions\":\"wp2b\"}],\"Focm\":[function(require,module,exports) {\nmodule.exports = require('./cpfFmt.ts').default;\n},{\"./cpfFmt.ts\":\"VRRp\"}]},{},[\"Focm\"], null)","const numOnly = require('@lacussoft/num-only')\nconst cpfFmt = require('@lacussoft/cpf-fmt')\n\n/**\n * Default options when runiing 'cpfGen' function\n *\n * @constant {object}\n */\nconst DEFAULT_OPTIONS = {\n  format: false,\n}\n\nconst mergeOptions = (options) => {\n  return Object.assign({}, DEFAULT_OPTIONS, options)\n}\n\n/**\n * Generate a string of integer numbers\n *\n * @param {number} length Number of digits to be generated\n * @return {string}\n */\nconst numGen = (length) => {\n  let string = ''\n  while (string.length < length) {\n    string += String(parseInt(Math.random() * 10))\n  }\n  return string\n}\n\n/**\n * Generate a valid CPF (Brazilian ID document) number sequence\n *\n * @param {object} [options]\n * @return {string}\n */\nconst cpfGen = function(options) {\n\n  if (arguments[1] !== undefined && typeof(arguments[1]) !== 'string' && numOnly(arguments[1]).length !== 9) {\n    throw new Error(`'${arguments[1]}' should be a string of 9 numbers length`)\n  }\n\n  let cpf = arguments[1] || numGen(9)\n  options = mergeOptions(options)\n\n  for (const nextNumIndex of [9, 10]) {\n    let sum = 0\n    let factor = nextNumIndex + 1\n    for (let n = 0; n < nextNumIndex; n++, factor--) {\n      sum += cpf[n] * factor\n    }\n    const rem = 11 - (sum % 11)\n    cpf += rem > 9 ? 0 : rem\n  }\n\n  if (options.format) {\n    return cpfFmt(cpf)\n  }\n\n  return cpf\n}\n\nmodule.exports = cpfGen\n","window.cpfGen = require('./core')\n"]}